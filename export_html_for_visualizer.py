from drift_analysis import extract_binary_data
from latex_results import load_measure_for_classifiers_pickles, normalized_absolute_error
import plotly.graph_objs as go
import random
import argparse
import multiprocessing
import numpy as np
import os
import tqdm

GITHUB_URL = "https://hlt-isti.github.io/SLD-visualization/"
PRIORS_PLOT_TYPE = "priors"
NAE_PLOT_TYPE = "nae"
POSTERIORS_PLOT_TYPE = "posteriors"
MINORITY_TYPE = "minority"
RANDOM_TYPE = "random"


def __make_plot_name(dir_path, plot_num, plot_type, class_type):
    return os.path.join(dir_path, f"{plot_num}_{plot_type}_{class_type}.html")


def add_trace_to_fig(fig, value, max_len, target_class, name):
    pad_width = (0, max_len - len(value))
    if len(value.shape) > 1:
        padded = np.pad(value, (pad_width, (0, 0)), mode='edge')
    else:
        padded = np.pad(value, pad_width, mode='edge')

    fig.add_trace(
        go.Scatter(
            x=np.array(range(args.iter_num)),
            y=padded[:, target_class] if len(value.shape) > 1 else padded,
            mode='lines',
            name=name,
            visible=True,
            legendgroup=name,
            showlegend=True
        )
    )


def extract_measures(meas_mean, isomerous):
    nae = np.array(
        [normalized_absolute_error(em_pr, test_pr) for em_pr, test_pr in zip(meas_mean.em_priors[1], meas_mean.test_priors[1])]
    )
    if isomerous:
        cal = np.array(meas_mean.isomerous_em_cal_loss[1])
        ref = np.array(meas_mean.isomerous_em_ref_loss[1])
    else:
        cal = np.array(meas_mean.isometric_em_cal_loss[1])
        ref = np.array(meas_mean.isometric_em_ref_loss[1])

    brier = cal + ref
    return nae, brier, cal, ref


def gen_plot_for_one_class(sample, target_class):
    test_priors = sample.test_priors[1][0]
    test_priors = np.array([test_priors[0][target_class]]) if len(test_priors.shape) > 1 else np.array([test_priors])
    em_priors = np.array(sample.em_priors[1])
    train_priors = sample.train_priors[1][0]
    train_priors = np.array([train_priors[0][target_class]]) if len(train_priors.shape) > 1 else np.array([train_priors])
    # At iteration 0 we show the true train priors (which are our initial priors in the SLD
    # algorithm, see em.py and sld_experiments.py in this repository)
    em_priors[0] = train_priors
    nae, brier, cal, ref = extract_measures(sample, True)
    max_len = len(sample.em_priors[1])

    prior_fig = go.Figure()
    nae_fig = go.Figure()
    posteriors_fig = go.Figure()

    for name, value in [('Prior in unlabelled set', test_priors), ('Prior in labelled set', train_priors),
                        ('Prior generated by SLD', em_priors)]:
        add_trace_to_fig(prior_fig, value, max_len, target_class, name)

    add_trace_to_fig(nae_fig, nae, max_len, target_class, "NAE")

    for name, value in [('BS', brier), ('CE', cal), ('RE', ref)]:
        add_trace_to_fig(posteriors_fig, value, max_len, target_class, name)

    prior_fig.update_layout(xaxis_title='SLD Iterations', legend=dict(y=1.2, x=.2, orientation='h'))
    nae_fig.update_layout(xaxis_title='SLD Iterations', legend=dict(y=1.2, x=.45, orientation='h'))
    posteriors_fig.update_layout(xaxis_title='SLD Iterations', legend=dict(y=1.2, x=.38, orientation='h'))
    prior_fig.update_xaxes(tick0=0, dtick=1)
    nae_fig.update_xaxes(tick0=0, dtick=1)
    posteriors_fig.update_xaxes(tick0=0, dtick=1)

    return prior_fig, nae_fig, posteriors_fig


def save_all_plot_classes(clf_name, n_targets, clf_measures):
    # For every plot we need to save:
    # - classifier name
    # - num of target classes
    # - minority or random class
    # - num of plot for that configuration
    # - priors, nae, posteriors type of plot
    samples = random.sample(clf_measures, args.num_plots)
    dir_path = os.path.join(args.path, clf_name, n_targets)
    os.makedirs(dir_path, exist_ok=True)
    for i, sample in enumerate(samples):
        if hasattr(sample.train_priors[1][0], '__len__'):
            minority_class = np.argmin(sample.train_priors[1][0])
            random_class = random.choice(range(len(sample.train_priors[1][0])))
        else:
            tr_priors = [1 - sample.train_priors[1][0], sample.train_priors[1][0]]
            minority_class = np.argmin(tr_priors)
            random_class = random.choice(range(len(tr_priors)))

        for c_type, class_ in [(MINORITY_TYPE, minority_class), (RANDOM_TYPE, random_class)]:
            prior_fig, nae_fig, posteriors_fig = gen_plot_for_one_class(sample, class_)
            prior_fig.write_html(__make_plot_name(dir_path, i, PRIORS_PLOT_TYPE, c_type), include_plotlyjs='cdn')
            nae_fig.write_html(__make_plot_name(dir_path, i, NAE_PLOT_TYPE, c_type), include_plotlyjs='cdn')
            posteriors_fig.write_html(__make_plot_name(dir_path, i, POSTERIORS_PLOT_TYPE, c_type), include_plotlyjs='cdn')


def extract_data_and_plot(n_targets, tqdm_position):
    measures = sorted(load_measure_for_classifiers_pickles("rcv1", n_targets), key=lambda k: k[0])
    if n_targets == "2":
        measures = list(map(lambda m: (m[0], list(m[1])), extract_binary_data(measures)))

    tqdm_meas = tqdm.tqdm(measures, desc=f"{n_targets} targets", position=tqdm_position)
    for clf_name, measure in tqdm_meas:
        save_all_plot_classes(clf_name, n_targets, measure)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog="HTML Plots exporter for the SLD experiments",
                                     description=f"Preprocess data and create html plots which will be later visualized"
                                                 f" in the SLD visualization tool (available at {GITHUB_URL})")
    parser.add_argument("-c", "--classes", nargs="+", help="Set for which classes you'd like to export results",
                        default=["2", "5", "10", "20", "37"])
    parser.add_argument("-n", "--num-plots", type=int, help="Set how many output plots should be generated for "
                                                            "each configuration", default=500)
    parser.add_argument("-j", "--num-jobs", type=int, help="Number of processes/jobs to run. Every process will take "
                                                           "care of one class specified with -c", default=5)
    parser.add_argument("-i", "--iter-num", type=int, help="Number of SLD iterations to show in the plots", default=7)
    parser.add_argument("-p", "--path", help="A structure of directories will be created in this path to save plots",
                        default="")

    args = parser.parse_args()

    with multiprocessing.Pool(processes=args.num_jobs) as p:

        async_results = []
        print("Loading data and generating plots...")
        for i, class_ in enumerate(args.classes):
            async_results.append(p.apply_async(extract_data_and_plot, args=(class_, i)))

        for a in async_results:
            a.wait()

